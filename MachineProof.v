(* TERSE: HIDEFROMHTML *)
Set Warnings "-notation-overridden,-parsing,-deprecated-hint-without-locality".
From Stdlib Require Import Strings.String.
From SECF Require Import TestingLib.
From SECF Require Import Utils.
From SECF Require Import MiniCET Machine.
From Stdlib Require Import Bool.Bool.
From Stdlib Require Import Arith.Arith.
From Stdlib Require Import Arith.EqNat.
From Stdlib Require Import Arith.PeanoNat. Import Nat.
From Stdlib Require Import Lia.
From Stdlib Require Import List. Import ListNotations.
Require Import ExtLib.Data.Monads.OptionMonad.
From SECF Require Import Maps MapsFunctor.
Set Default Goal Selector "!".
(* TERSE: /HIDEFROMHTML *)

Module MCC := MiniCETCommon(TotalMap).
Import MCC.

(** Sequential small-step semantics for Machine *)

(* Reserved Notation *)
(*   "p '|-' '<((' c '))>' '-->^' os '<((' ct '))>'" *)
(*   (at level 40, c constr, ct constr). *)

(* Inductive seq_eval_small_step_inst (p:prog) : *)
(*   @state cfg -> @state cfg -> obs -> Prop := *)
(*   | SSMI_Skip : forall pc rs m stk, *)
(*       p[[pc]] = Some <{{ skip }}> -> *)
(*       p |- <(( S_Running (pc, rs, m, stk) ))> -->^[] <(( S_Running (pc+1, rs, m, stk) ))> *)
(*   | SSMI_Asgn : forall pc r m sk e x, *)
(*       p[[pc]] = Some <{{ x := e }}> -> *)
(*       p |- <(( S_Running (pc, r, m, sk) ))> -->^[] <(( S_Running (pc+1, (x !-> (eval r e); r), m, sk) ))> *)
(*   | SSMI_Branch : forall pc pc' r m sk e n l, *)
(*       to_nat (eval r e) = Some n -> *)
(*       pc' = (if (not_zero n) then (l,0) else pc+1) -> *)
(*       p |- <(( S_Running (pc, r, m, sk) ))> -->^[OBranch (not_zero n)] <(( S_Running (pc', r, m, sk) ))> *)
(*   | SSMI_Jump : forall l pc r m sk, *)
(*       p[[pc]] = Some <{{ jump l }}> -> *)
(*       p |- <(( S_Running (pc, r, m, sk) ))> -->^[] <(( S_Running ((l,0), r, m, sk) ))> *)
(*   | SSMI_Load : forall pc r m sk x e n v', *)
(*       p[[pc]] = Some <{{ x <- load[e] }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       nth_error m n = Some v' -> *)
(*       p |- <(( S_Running (pc, r, m, sk) ))> -->^[OLoad n] <(( S_Running (pc+1, (x !-> v'; r), m, sk) ))> *)
(*   | SSMI_Store : forall pc r m sk e e' n, *)
(*       p[[pc]] = Some <{{ store[e] <- e' }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       p |- <(( S_Running (pc, r, m, sk) ))> -->^[OStore n] <(( S_Running (pc+1, r, upd n m (eval r e'), sk) ))> *)
(*   | SSMI_Call : forall pc r m sk e l, *)
(*       p[[pc]] = Some <{{ call e }}> -> *)
(*       to_fp (eval r e) = Some l -> *)
(*       p |- <(( S_Running (pc, r, m, sk) ))> -->^[OCall l] <(( S_Running ((l,0), r, m, ((pc+1)::sk)) ))> *)
(*   | SSMI_Ret : forall pc r m sk pc', *)
(*       p[[pc]] = Some <{{ ret }}> -> *)
(*       p |- <(( S_Running (pc, r, m, pc'::sk) ))> -->^[] <(( S_Running (pc', r, m, sk) ))> *)
(*   | SSMI_Term : forall pc r m, *)
(*       p[[pc]] = Some <{{ ret}}> -> *)
(*       p |- <(( S_Running (pc, r, m, []) ))> -->^[] <(( S_Term ))> *)

(*   where "p |- <(( c ))> -->^ os <(( ct ))>" := *)
(*       (seq_eval_small_step_inst p c ct os). *)

(* (** Sequential multi-step relation *) *)

(* Reserved Notation *)
(*   "p '|-' '<((' c '))>' '-->*^' os '<((' ct '))>'" *)
(*       (at level 40, c constr, ct constr). *)

(* Inductive multi_seq_inst (p : prog) (c : @state cfg) : @state cfg -> obs -> Prop := *)
(*   | multi_seq_inst_refl : p |- <(( c ))> -->*^[] <(( c ))> *)
(*   | multi_seq_inst_trans (c' c'' : @state cfg) (os1 os2 : obs) : *)
(*       p |- <(( c ))> -->^os1 <(( c' ))> -> *)
(*       p |- <(( c' ))> -->*^os2 <(( c'' ))> -> *)
(*       p |- <(( c ))> -->*^(os1 ++ os2) <(( c'' ))> *)

(*   where "p |- <(( c ))> -->*^ os <(( ct ))>" := *)
(*       (multi_seq_inst p c ct os). *)

(* (** Speculative small-step semantics for MiniCET *) *)

(* Reserved Notation *)
(*   "p '|-' '<((' sc '))>' '-->_' ds '^^' os '<((' sct '))>'" *)
(*   (at level 40, sc constr, sct constr). *)

(* Inductive spec_eval_small_step (p:prog): *)
(*     @state spec_cfg -> @state spec_cfg -> dirs -> obs -> Prop := *)
(*   | SpecSMI_Skip  :  forall pc r m sk ms, *)
(*       p[[pc]] = Some <{{ skip }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[]^^[] <(( S_Running ((pc+1, r, m, sk), false, ms) ))> *)
(*   | SpecSMI_Asgn : forall pc r m sk ms e x, *)
(*       p[[pc]] = Some <{{ x := e }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[]^^[] <(( S_Running ((pc+1, (x !-> (eval r e); r), m, sk), false, ms) ))> *)
(*   | SpecSMI_Branch : forall pc pc' r m sk ms ms' b (b': bool) e n l, *)
(*       p[[pc]] = Some <{{ branch e to l }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       b = (not_zero n) -> *)
(*       pc' = (if b' then (l, 0) else (pc+1)) -> *)
(*       ms' = ms || negb (Bool.eqb b b') -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[DBranch b']^^[OBranch b] <(( S_Running ((pc', r, m, sk), false, ms') ))> *)
(*   | SpecSMI_Jump : forall l pc r m sk ms, *)
(*       p[[pc]] = Some <{{ jump l }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[]^^[] <(( S_Running (((l,0), r, m, sk), false, ms) ))> *)
(*   | SpecSMI_Load : forall pc r m sk x e n v' ms, *)
(*       p[[pc]] = Some <{{ x <- load[e] }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       nth_error m n = Some v' -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[]^^[OLoad n] <(( S_Running ((pc+1, (x !-> v'; r), m, sk), false, ms) ))> *)
(*   | SpecSMI_Store : forall pc r m sk e e' n ms, *)
(*       p[[pc]] = Some <{{ store[e] <- e' }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[]^^[OStore n] <(( S_Running ((pc+1, r, upd n m (eval r e'), sk), false, ms) ))> *)
(*   | SpecSMI_Call : forall pc pc' r m sk e l ms ms', *)
(*       p[[pc]] = Some <{{ call e }}> -> *)
(*       to_fp (eval r e) = Some l -> *)
(*       ms' = ms || negb ((fst pc' =? l) && (snd pc' =? 0)) -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[DCall pc']^^[OCall l] <(( S_Running ((pc', r, m, (pc+1)::sk), true, ms') ))> *)
(*   | SpecSMI_CTarget : forall pc r m sk ms, *)
(*       p[[pc]] = Some <{{ ctarget }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), true, ms) ))> -->_[]^^[] <(( S_Running ((pc+1, r, m, sk), false, ms) ))> *)
(*   | SpecSMI_CTarget_F : forall pc r m sk ms, *)
(*       p[[pc]] = Some <{{ ctarget }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), false, ms) ))> -->_[]^^[] <(( S_Fault ))> *)
(*   | SpecSMI_Ret : forall pc r m sk pc' ms, *)
(*       p[[pc]] = Some <{{ ret }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, pc'::sk), false, ms) ))> -->_[]^^[] <(( S_Running ((pc', r, m, sk), false, ms) ))> *)
(*   | SpecSMI_Term : forall pc r m ms, *)
(*       p[[pc]] = Some <{{ ret }}> ->  *)
(*       p |- <(( S_Running ((pc, r, m, []), false, ms) ))> -->_[]^^[] <(( S_Term ))> *)

(*   where "p |- <(( sc ))> -->_ ds ^^ os  <(( sct ))>" := *)
(*     (spec_eval_small_step p sc sct ds os). *)

(* (** Speculative multi-step relation *) *)

(* Reserved Notation *)
(*   "p '|-' '<((' sc '))>' '-->*_' ds '^^' os '^^' n '<((' sct '))>'" *)
(*   (at level 40, sc constr, sct constr). *)

(* Inductive multi_spec_inst (p:prog) : *)
(*   @state spec_cfg -> @state spec_cfg -> dirs -> obs -> nat -> Prop := *)
(*   | multi_spec_inst_refl sc : p |- <(( sc ))> -->*_[]^^[]^^0 <(( sc ))> *)
(*   |multi_spec_inst_trans sc1 sc2 sc3 ds1 ds2 os1 os2 n : *)
(*       p |- <(( sc1 ))> -->_ds1^^os1 <(( sc2 ))> -> *)
(*       p |- <(( sc2 ))> -->*_ds2^^os2^^n <(( sc3 ))> -> *)
(*       p |- <(( sc1 ))> -->*_(ds1++ds2)^^(os1++os2)^^(S n) <(( sc3 ))> *)

(*   where "p |- <(( sc ))> -->*_ ds ^^ os ^^ n <(( sct ))>" := *)
(*     (multi_spec_inst p sc sct ds os n). *)

(* (** Ideal small-step semantics for MiniCET *) *)

(* Reserved Notation *)
(*   "p '|-' '<((' ic '))>' '-->i_' ds '^^' os '<((' ict '))>'" *)
(*   (at level 40, ic constr, ict constr). *)

(* Inductive ideal_eval_small_step_inst (p:prog) : *)
(*   @state ideal_cfg -> @state ideal_cfg -> dirs -> obs -> Prop := *)
(*   | ISMI_Skip  :  forall pc r m sk ms, *)
(*       p[[pc]] = Some <{{ skip }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[]^^[] <(( S_Running ((pc+1, r, m, sk), ms) ))> *)
(*   | ISMI_Asgn : forall pc r m sk ms e x, *)
(*       p[[pc]] = Some <{{ x := e }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[]^^[] <(( S_Running ((pc+1, (x !-> (eval r e); r), m, sk), ms) ))> *)
(*   | ISMI_Branch : forall pc pc' r m sk (ms ms' b b' : bool) e n n' l, *)
(*       p[[pc]] = Some <{{ branch e to l }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       n' = (if ms then 0 else n) -> (* uslh masking *) *)
(*       b = (not_zero n') -> *)
(*       pc' = (if b' then (l,0) else pc+1) -> *)
(*       ms' = (ms || (negb (Bool.eqb b b'))) -> *)
(*       (* uslh imposes that if we're already speculating the branch condition is always false *) *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[DBranch b']^^[OBranch b] <(( S_Running ((pc', r, m, sk), ms') ))> *)
(*   | ISMI_Jump : forall l pc r m sk ms, *)
(*       p[[pc]] = Some <{{ jump l }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[]^^[] <(( S_Running (((l,0), r, m, sk), ms) ))> *)
(*   | ISMI_Load : forall pc r m sk x e n n' v' (ms : bool), *)
(*       p[[pc]] = Some <{{ x <- load[e] }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       nth_error m n = Some v' -> *)
(*       n' = (if ms then 0 else n) -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[]^^[OLoad n'] <(( S_Running ((pc+1, (x !-> v'; r), m, sk), ms) ))> *)
(*   | ISMI_Store : forall pc r m sk e e' e'' n (ms : bool), *)
(*       p[[pc]] = Some <{{ store[e] <- e' }}> -> *)
(*       to_nat (eval r e) = Some n -> *)
(*       e'' = (if ms then 0 else n) -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[]^^[OStore e''] <(( S_Running ((pc+1, r, upd n m (eval r e'), sk), ms) ))> *)
(*   (* no fault if program goes to the beginning of some procedure block, whether or not it's the intended one *) *)
(*   | ISMI_Call : forall pc pc' r m sk e l l' (ms ms' : bool) blk, *)
(*       p[[pc]] = Some <{{ call e }}> -> *)
(*       to_fp (eval r e) = Some l -> *)
(*       l' = (if ms then 0 else l) -> (* uslh masking *) *)
(*       ms' = ms || negb (fst pc' =? l) -> *)
(*       nth_error p (fst pc') = Some blk -> (* always established by well-formed directive *) *)
(*       snd blk = true -> *)
(*       snd pc' = 0 -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[DCall pc']^^[OCall l'] <(( S_Running ((pc', r, m, (pc+1)::sk), ms') ))> *)
(*   (* fault if attacker pc goes to non-proc block or into the middle of any block *) *)
(*   (* directives are always "well-formed": nth_error p (fst pc') = Some blk /\ nth_error blk (snd pc') = Some i always established. *) *)
(*   | ISMI_Call_F : forall pc pc' r m sk e l l' (ms ms' : bool), *)
(*       p[[pc]] = Some <{{ call e }}> -> *)
(*       to_fp (eval r e) = Some l -> *)
(*       l' = (if ms then 0 else l) -> (* uslh masking *) *)
(*       (forall blk, nth_error p (fst pc') = Some blk -> snd blk = false \/ snd pc' <> 0) -> *)
(*       p |- <(( S_Running ((pc, r, m, sk), ms) ))> -->i_[DCall pc']^^[OCall l'] <(( S_Fault ))> *)
(*   | ISMI_Ret : forall pc r m sk pc' ms, *)
(*       p[[pc]] = Some <{{ ret }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, pc'::sk), ms) ))> -->i_[]^^[] <(( S_Running ((pc', r, m, sk), ms) ))> *)
(*   | ISMI_Term : forall pc r m ms, *)
(*       p[[pc]] = Some <{{ ret }}> -> *)
(*       p |- <(( S_Running ((pc, r, m, []), ms) ))> -->i_[]^^[] <(( S_Term ))> *)

(*   where "p |- <(( ic ))> -->i_ ds ^^ os  <(( ict ))>" := *)
(*     (ideal_eval_small_step_inst p ic ict ds os). *)

(* (** Ideal multi-step relation *) *)

(* Reserved Notation *)
(*   "p '|-' '<((' ic '))>' '-->i*_' ds '^^' os '<((' ict '))>'" *)
(*   (at level 40, ic constr, ict constr). *)

(* Inductive multi_ideal_inst (p:prog) : *)
(*   @state ideal_cfg -> @state ideal_cfg -> dirs -> obs -> Prop := *)
(*   | multi_ideal_inst_refl ic : p |- <(( ic ))> -->i*_[]^^[] <(( ic ))> *)
(*   | multi_ideal_inst_trans ic1 ic2 ic3 ds1 ds2 os1 os2 : *)
(*       p |- <(( ic1 ))> -->i_ds1^^os1 <(( ic2 ))> -> *)
(*       p |- <(( ic2 ))> -->i*_ds2^^os2 <(( ic3 ))> -> *)
(*       p |- <(( ic1 ))> -->i*_(ds1++ds2)^^(os1++os2) <(( ic3 ))> *)
(*   where "p |- <(( ic ))> -->i*_ ds ^^ os <(( ict ))>" := *)
(*     (multi_ideal_inst p ic ict ds os). *)


